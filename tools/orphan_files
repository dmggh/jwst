#! /usr/bin/env python
"""This script looks for inconsitencies between the server database, 
server file cache at CRDS_PATH, and the server catalogs and deliveries directories.

When used to maintain a single server,  the switch --purge-delivery-errors can
clean up files in the catalog and delivery directories.

When used in the context of mirroring,  --purge-delivery-errors is moot because
the catalogs and deliveries directories are recreated.
"""
import sys
import os.path
import glob
import re

from crds import rmap, log
from crds.server import config
from crds.server.interactive import models as imodels

def file_conjugate(path):
    """Nominally the opposing half of a GEIS file,  data for header or header for data.
    Easily expandable to any binary filetype, less so to multi-part non-binary types.
    """
    if re.match(".*\.r\dd", path):
        conjugate = path[:-1] + "h"
    elif re.match(".*\.r\dh", path):
        conjugate = path[:-1] + "d"
    else:
        conjugate = None
    return conjugate

def check_exists(path):
    if not os.path.exists(path):
        return False
    conjugate = file_conjugate(path)
    if conjugate:
        if not os.path.exists(cojugate):
            log.error("Missing file conjugate", repr(conjugate), "corresponding to", repr(path))
            return False
        else:
            log.verbose("Checking file congjugate", repr(conjugate), "corrsponding to", repr(path), "exists.")
    return True

def all_rules_files(mapping_glob="*.*map"):
    """Return (mapping_names, reference_names) for all mappings which match `mapping_glob`"""
    all, mappings, references = [], [], []
    for fname in rmap.list_mappings(mapping_glob, observatory=imodels.OBSERVATORY):
        with log.error_on_exception("FAILED loading mapping", repr(fname)):
            pmap = rmap.get_cached_mapping(fname)
            references += pmap.reference_names()
            mappings += pmap.mapping_names()
            all = references + mappings
    return set(all)

def check_files():
    db_files = imodels.get_fileblob_map()
    cached_files = rmap.list_mappings("*", imodels.OBSERVATORY) + rmap.list_references("*", imodels.OBSERVATORY)
    mapping_files = all_rules_files()
    check_consistency("database", "cache", db_files, cached_files)
    check_consistency("database", "mappings", db_files, mapping_files)
    check_consistency("cache", "mappings", cached_files, mapping_files)

def check_consistency(name1, name2, files1, files2):
    _check_consistency(name1, name2, files1, files2)
    _check_consistency(name2, name1, files2, files1)

def _check_consistency(name1, name2, files1, files2):
    for file in files1:
        log.verbose("Checking", name1, "file", repr(file), "against", name2)
        if file not in files2 and file_conjugate(file) not in files2:
            log.error("Orphaned", name1, "file", repr(file), "is not in", name2)
        conjugate = file_conjugate(file)
        if conjugate and name2 != "mappings":
            log.verbose("Checking", name1, "conjugate", repr(conjugate), "corresponding to", repr(file), "against", name2)
            if conjugate not in files2:
                log.error("Missing", name1, "conjugate", repr(conjugate), "is not in", name2)

def delivered_path(name):
    return os.path.join(config.CRDS_DELIVERY_DIR, name)

def check_catalog_files():
    """Check consistency between CRDS catalogs in delivery area and delivered files."""
    db_files = imodels.get_fileblob_map()
    pending_catalogs = glob.glob(config.CRDS_DELIVERY_DIR + "/*.*cat")
    all_catalogued_files = []
    for catalog in pending_catalogs:
        log.verbose("Scanning catalog", repr(catalog))
        manifested_files = open(catalog).read().splitlines()
        for manifested_file in manifested_files:
            log.verbose("Scanning manifested file", repr(manifested_file))
            manifest_path = delivered_path(manifested_file)
            if not check_exists(manifest_path):
                purge_delivered_file(catalog, "Manifested file", repr(manifest_path), "from catalog", 
                                    repr(catalog), "does not exist.")
                
            if manifested_file not in db_files:
                purge_delivered_file(manifest_path, "Manifested file", repr(manifest_path), "from catalog", 
                                    repr(catalog), "is not known to CRDS.")
        all_catalogued_files += manifested_files
    delivered_files = glob.glob(config.CRDS_DELIVERY_DIR + "/*")
    for file in delivered_files:
        if ".cat" not in file and os.path.basename(file) not in all_catalogued_files:
            purge_delivered_file(file, "Delivered file", repr(file), "has no corresponding catalog.")
    for file in [ f for f in db_files.values() if f.state == "delivered" ]:
        if file.name not in all_catalogued_files:
            log.error("File", repr(file.name), "with state 'delivered' has no catalog entry.")
        if not os.path.exists(delivered_path(file.name)):
            log.error("File", repr(file.name), "with state 'delivered' has no delivered file link.")
    for file in [ f for f in db_files.values() if f.state == "uploaded" ]:
        log.warning("File", repr(file.name), "delivered on", file.delivery_date, "has state 'uploaded'.")

def purge_delivered_file(filepath, *args, **keys):
    """Remove `filepath` and issue an error message defined by `args` and `keys`."""
    log.error(*args, **keys)
    try:
        if "--purge-delivery-errors" in sys.argv:
            os.chmod(filepath, int('0666', 8))
            os.remove(filepath)
            log.info("Removed", repr(filepath))
    except Exception:
        pass

def main():
    if "--verbose" in sys.argv:
        log.set_verbose()
    check_files()
    check_catalog_files()
    log.standard_status()

if __name__ == "__main__":
    main()

