{% extends "base.html" %}

{% block column1 %}

<script type="text/javascript">
      
      function readBlob(input_id, continuation, opt_startByte, opt_stopByte) {    
            var files = document.getElementById(input_id).files;
            if (!files.length) {
              alert('Please select a file!');
              return;
            }
            var file = files[0];
            var start = parseInt(opt_startByte) || 0;
            var stop = parseInt(opt_stopByte) || file.size - 1;
        
            var reader = new FileReader();
        
            // If we use onloadend, we need to check the readyState.
            reader.onloadend = function(evt) {
              if (evt.target.readyState == FileReader.DONE) { 
                var contents = evt.target.result;
                continuation(contents);
              }
            };
            
            if (file.webkitSlice) {
              var blob = file.webkitSlice(start, stop + 1);
            } else if (file.mozSlice) {
              var blob = file.mozSlice(start, stop + 1);
            } else {
              alert("File blob interface not supported for this browser.  Use a different mode or switch browsers.  Recent Firefox or Chrome browsers work.");
            }  
            reader.readAsText(blob);        
      }
      
      function get_header(filename, file_string) {
            if (/.fits$/.test(filename)) {
                return fits_get_header(file_string);
            } else {
                alert("Browser can't handle headers for this file type.   Use 'Uploaded' instead.");
                return "";
            }
      }
      
      function fits_get_header(file_string) {
            var record_no = 0;
            var rec = fits_read_record(file_string, record_no);
            var header = "";
            while (rec.length) {
                var result = header_lines(get_cards(rec));
                header += result[0];
                if (result[1]) {
                    return header;
                }
                record_no += 1;
                rec = fits_read_record(file_string, record_no);
            }
            return header;
      }
      
      function fits_read_record(file_string, record_no) {  // read a FITS record
        var beg = 2880*record_no;
        var end = Math.min(file_string.length, 2880*(record_no + 1));
        // console.log(record_no + " " + beg + " " + end);
        return file_string.slice(beg, end);
      }
      
      function get_cards(record) {
        var i = 0;
        var cards = new Array();
        for ( ; 80*i < record.length; i++) {
            cards[i] = record.slice(80*i, 80*(i+1));
        }
        return cards;
      }
      
      function header_lines(cards) { // Return "header lines" assoc with cards
        var i;
        var header = "";
        for(i in cards) {
            var card = cards[i];
            if (card.slice(8,9) == "=") {
                header += card_line(card);
            } else {
                console.log("skipping card: " + card)
            }
            if (fits_keyword(card) == "END") {
                return [ header, true ];
            }
        }
        return [ header, false ];
      }
      
      function card_line(card) {  // format a card into "<key> <value> <eol>"
            var key = fits_keyword(card);
            var value;   
            if (card.indexOf("/") > 0) { // handle comments
                value = $.trim(card.slice(10, card.indexOf("/")));
            } else {
                value = $.trim(card.slice(10, card.length));
            }
            if (value[0] == "'") {
                value = $.trim(value.slice(1, value.length-1));
            }
            var line = key + " " + value + "\n";
            if ($.trim(line)) {
                return line;
            } else {
                return "";
            }
      }
      
      function fits_keyword(card) {   // return the FITS keyword of a card.
        return $.trim(card.slice(0,8));
      }     
      
      function set_contents(file) {
        
        crds.set_info_box({text: "Loading FITS header..."});                                   
        crds.append_info_box({text: "This may take a while for large files.", css:{color:"darkblue"}});
                                   
        readBlob(file.id, function (contents) {
            // replace the file element with a text area containing header lines
            var header_val = get_header(file.value, contents);
            if (!header_val) {
                file.value = "";
                crds.set_radio("dataset_mode","dataset_uploaded");
                return;
            }
            var header_textarea = $("<textarea name='dataset_local' rows='5' cols='40'>")
                                 .text(header_val)
            var dataset_name = $("<input type='hidden' name='dataset_name'/>")
                                .val(crds.basename(file.value));
            $("#dataset_local").after(header_textarea);
            header_textarea.after(dataset_name);
            $("#dataset_local").remove();
            $(file).val(crds.basename(file.value))
        }); 
        crds.set_radio("dataset_mode", "dataset_local");
        crds.clear_info_box();
      };
      
      function validate(evt) {
        if (!crds.validate_select_pmap()) {
            return false;
        }
        var dataset_mode = $("input[name='dataset_mode']:checked").val();
        console.log("dataset_mode", dataset_mode);
        if (dataset_mode == "dataset_uploaded") {
            if ($("#dataset_uploaded")[0].files.length == 0) {
                alert("Did you add some files?");
                return false;
            }
        } else if (dataset_mode == "dataset_archive") {
            if (!$("#dataset_archive").val()) {
                alert("Did you set the dataset id?");
                return false;
            }
        } else if (dataset_mode == "dataset_local") {
            if (!$("textarea[name='dataset_local']").length) {
                alert("Did you choose a FITS file to extract a header from?");
                return false;
            }   
        } else {
            console.log("Invalid dataset_mode");
        }
        
        return true;
      }
</script>


  <form id="raw_form" action="/bestrefs/" method="post"" enctype="multipart/form-data"
        onsubmit="return validate(event);"> {% csrf_token %}
    <h2>Dataset Best References</h2>
    
    <h3>Context:</h3>
    {% include "select_pmap.html" %}
    
    <h3>Dataset:</h3>
    <table>
      <tr>
        <td class="h4">
            <input type="radio" name="dataset_mode" value="dataset_local" checked>Upload FITS Header
        </td>
        <td align="left">
            <input type='file' id='dataset_local' onchange='set_contents(this);' />
        </td>
      </tr>
      {% if is_authenticated %}
      <tr>
        <td class="h4">
           <input type="radio" name="dataset_mode" value="dataset_uploaded">Upload Dataset
        </td>
        <td align="right">
           <input type="file" class="multi" maxlength="1" name="dataset_uploaded"
                    id="dataset_uploaded" onchange="crds.set_radio('dataset_mode', 'dataset_uploaded');" />
        </td> 
      </tr>
      {% endif %}
      <tr>
        <td class="h4">
            <input type="radio" name="dataset_mode" value="dataset_archive" />Archived Dataset ID
        </td>
        <td align="left">
            <input type="text" width="32" name="dataset_archive" id="dataset_archive"
                    value="{{dataset_archive}}" 
                    onchange="crds.set_radio('dataset_mode','dataset_archive');" />
            <span class='hint'>.e.g. I9ZF01010</span>
        </td>
      </tr>
    </table>
    
    <br/>
    <input type="submit" value="Submit" />
    
  </form>
{% endblock column1 %}

{% block bottom_help %}

    <p><b>Dataset Best References</b> lets you determine the best reference files 
    for an archived or uploaded dataset, relative to the chosen CRDS context.
    
    <p><p><b>Context</b> this section defines the version of the pipeline 
    context that should be used to determine the best reference files. The 
    context file chosen defines the parameter choices which will be available 
    as well as complete file selection criteria.

    <p><p><b>Dataset</b> Dataset specifies the name of an archived or uploaded 
    dataset for which the user needs to know the best references files that are 
    defined by the chosen context.  Upload FITS Header uses your browser to 
    minimize file information uploaded to the server for FITS files.
    
    <p><p><b>NOTE:</b> For doing production data calibration and working with multiple
    datasets utilize command line (HST crds.bestrefs) or built-in (JWST calibration steps) tools.   This page 
    is intended as a quick reference and debug resource for single datasets.   The command line tools
    will both update dataset headers and transparently download required references to a local
    cache as needed.   On site,  typically a shared readonly cache is used and no file downloads
    are required.  Regardless of caching,  the command line tools are designed to efficiently
    determine bestrefs for large numbers of datasets and update headers as required.
    
    {% if observatory|upper == "HST" %}
    <p><p> For HST, the program crds.bestrefs can be invoked like this:
    
    <pre class="code" style="font-size: 1.2em;">
    
    # For a small scale personal CRDS cache
    % setenv CRDS_PATH $HOME/crds_cache
    
    % setenv CRDS_SERVER_URL https://hst-crds.stsci.edu
    
    # To download the CRDS rules for the current context to your cache
    % python -m crds.sync --contexts hst-operational
    
    # To update the headers of some dataset .fits files,  and download the recommended references to the local cache.
    % python -m crds.bestrefs --new-context hst-operational --sync-references --update-bestrefs --files *_raw.fits
    
    # setenv iref$, jref$, etc. to  ${CRDS_PATH}/references/hst for processing.
    </pre>
    
    <p><p>Using --sync-references will download the recommended best references to the local cache defined by CRDS_PATH.
    For typical on site institutional use,  CRDS_PATH will point to a global, shared, read-only cache and --sync-references
    should be omitted.
    {% endif %}

    {% if observatory|upper == "JWST" %}
    
    <p><p> For JWST, CRDS bestrefs are automatically invoked as part of running calibration steps.  
    <p><p>At STScI, a default readonly file cache is available and hence CRDS_PATH and CRDS_SERVER_URL do not need to 
    be set.   However,  if you want to have a local personal cache (say on your laptop for telecommuting or working 
    with a small number of datasets) then settings like the following are appropriate:
    
    <pre class="code" >
    % setenv CRDS_PATH $HOME/crds_cache   # For a small scale personal cache
    % setenv CRDS_SERVER_URL https://jwst-crds.stsci.edu
    % ... run calibration steps ...
    </pre>
    
    {% endif %}
    
    
    
{% endblock bottom_help %}