{% extends "base.html" %}

{% block column1 %}

<script type="text/javascript">
      
      function readBlob(input_id, continuation, opt_startByte, opt_stopByte) {    
            var files = document.getElementById(input_id).files;
            if (!files.length) {
              alert('Please select a file!');
              return;
            }
            var file = files[0];
            var start = parseInt(opt_startByte) || 0;
            var stop = parseInt(opt_stopByte) || file.size - 1;
        
            var reader = new FileReader();
        
            // If we use onloadend, we need to check the readyState.
            reader.onloadend = function(evt) {
              if (evt.target.readyState == FileReader.DONE) { 
                var contents = evt.target.result;
                continuation(contents);
              }
            };
            
            if (file.webkitSlice) {
              var blob = file.webkitSlice(start, stop + 1);
            } else if (file.mozSlice) {
              var blob = file.mozSlice(start, stop + 1);
            } else {
              alert("File blob interface not supported for this browser.  Use a different mode or switch browsers.  Recent Firefox or Chrome browsers work.");
            }  
            reader.readAsText(blob);        
      }
      
      function get_header(filename, file_string) {
            if (/.fits$/.test(filename)) {
                return fits_get_header(file_string);
            } else {
                alert("Browser can't handle headers for this file type.   Use 'Uploaded' instead.");
                return "";
            }
      }
      
      function fits_get_header(file_string) {
            var record_no = 0;
            var rec = fits_read_record(file_string, record_no);
            var header = "";
            while (rec.length) {
                var result = header_lines(get_cards(rec));
                header += result[0];
                if (result[1]) {
                    return header;
                }
                record_no += 1;
                rec = fits_read_record(file_string, record_no);
            }
            return header;
      }
      
      function fits_read_record(file_string, record_no) {  // read a FITS record
        var beg = 2880*record_no;
        var end = Math.min(file_string.length, 2880*(record_no + 1));
        // console.log(record_no + " " + beg + " " + end);
        return file_string.slice(beg, end);
      }
      
      function get_cards(record) {
        var i = 0;
        var cards = new Array();
        for ( ; 80*i < record.length; i++) {
            cards[i] = record.slice(80*i, 80*(i+1));
        }
        return cards;
      }
      
      function header_lines(cards) { // Return "header lines" assoc with cards
        var i;
        var header = "";
        for(i in cards) {
            var card = cards[i];
            if (card.slice(8,9) == "=") {
                header += card_line(card);
            } else {
                console.log("skipping card: " + card)
            }
            if (fits_keyword(card) == "END") {
                return [ header, true ];
            }
        }
        return [ header, false ];
      }
      
      function card_line(card) {  // format a card into "<key> <value> <eol>"
            var key = fits_keyword(card);
            var value;   
            if (card.indexOf("/") > 0) { // handle comments
                value = $.trim(card.slice(10, card.indexOf("/")));
            } else {
                value = $.trim(card.slice(10, card.length));
            }
            if (value[0] == "'") {
                value = $.trim(value.slice(1, value.length-1));
            }
            var line = key + " " + value + "\n";
            if ($.trim(line)) {
                return line;
            } else {
                return "";
            }
      }
      
      function fits_keyword(card) {   // return the FITS keyword of a card.
        return $.trim(card.slice(0,8));
      }     
      
      function set_contents(file) {
        
        crds.set_info_box({text: "Loading FITS header..."});                                   
        crds.append_info_box({text: "This may take a while for large files.", css:{color:"darkblue"}});
                                   
        readBlob(file.id, function (contents) {
            // replace the file element with a text area containing header lines
            var header_val = get_header(file.value, contents);
            if (!header_val) {
                file.value = "";
                crds.set_radio("dataset_mode","dataset_uploaded");
                return;
            }
            var header_textarea = $("<textarea name='dataset_local' rows='5' cols='40'>")
                                 .text(header_val)
            var dataset_name = $("<input type='hidden' name='dataset_name'/>")
                                .val(crds.basename(file.value));
            $("#dataset_local").after(header_textarea);
            header_textarea.after(dataset_name);
            $("#dataset_local").remove();
            $(file).val(crds.basename(file.value))
        }); 
        crds.set_radio("dataset_mode", "dataset_local");
        crds.clear_info_box();
      };
      
      function validate(evt) {
        if (!crds.validate_select_pmap()) {
            return false;
        }
        var dataset_mode = $("input[name='dataset_mode']:checked").val();
        console.log("dataset_mode", dataset_mode);
        if (dataset_mode == "dataset_uploaded") {
            if ($("#dataset_uploaded")[0].files.length == 0) {
                alert("Did you add some files?");
                return false;
            }
        } else if (dataset_mode == "dataset_archive") {
            if (!$("#dataset_archive").val()) {
                alert("Did you set the dataset id?");
                return false;
            }
        } else if (dataset_mode == "dataset_local") {
            if (!$("textarea[name='dataset_local']").length) {
                alert("Did you choose a FITS file to extract a header from?");
                return false;
            }   
        } else {
            console.log("Invalid dataset_mode");
        }
        
        return true;
      }
</script>


  <form id="raw_form" action="/bestrefs/" method="post"" enctype="multipart/form-data"
        onsubmit="return validate(event);"> {% csrf_token %}
    <h2>Dataset Best References</h2>
    
    <h3>Context:</h3>
    {% include "select_pmap.html" %}
    
    <h3>Dataset:</h3>
    <table>
      <tr>
        <td class="h4">
            <input type="radio" name="dataset_mode" value="dataset_local" checked>Upload FITS Header
        </td>
        <td align="left">
            <input type='file' id='dataset_local' onchange='set_contents(this);' />
        </td>
      </tr>
      {% if is_authenticated %}
      <tr>
        <td class="h4">
           <input type="radio" name="dataset_mode" value="dataset_uploaded">Upload Dataset
        </td>
        <td align="right">
           <input type="file" class="multi" maxlength="1" name="dataset_uploaded"
                    id="dataset_uploaded" onchange="crds.set_radio('dataset_mode', 'dataset_uploaded');" />
        </td> 
      </tr>
      {% endif %}
      <tr>
        <td class="h4">
            <input type="radio" name="dataset_mode" value="dataset_archive" />Catalog Dataset ID
        </td>
        <td align="left">
            <input type="text" width="32" name="dataset_archive" id="dataset_archive"
                    value="{{dataset_archive}}" 
                    onchange="crds.set_radio('dataset_mode','dataset_archive');" />
            <span class='hint'>.e.g. I9ZF01010</span>
        </td>
      </tr>
    </table>
    
    <br/>
    <input type="submit" value="Submit" />
    
  </form>
{% endblock column1 %}

{% block help %}
    <p><b>Dataset Best References</b> determines the best reference files 
    for an archived or uploaded dataset header, relative to the chosen CRDS context.
    
    <p><p><b>Context</b> defines the version of rules that should be used to determine 
    best references. The context file chosen defines the parameter choices which 
    will be available as well as file selection rules.

    <p><p><b>Dataset</b> Cataloged dataset id specifies the name of a cataloged parameter set 
    for which to determine best references.  If the dataset id names an association,  the results
    returned are for the first member of the association.

    <p><p>Upload FITS Header loads reference matching parameters from a FITS file on your local system;   
    the loaded matching parameters may be edited in the browser.

{% endblock help %}

{% block bottom_help %}
    {% include "bestrefs_bottom_help.html" %}
{% endblock bottom_help %}

