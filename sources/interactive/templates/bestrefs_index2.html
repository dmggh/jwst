{% extends "base.html" %}

{% block column1 %}

<script type="text/javascript">
      
      function readBlob(input_id, continuation, opt_startByte, opt_stopByte) {    
            var files = document.getElementById(input_id).files;
            if (!files.length) {
              alert('Please select a file!');
              return;
            }
            var file = files[0];
            var start = parseInt(opt_startByte) || 0;
            var stop = parseInt(opt_stopByte) || file.size - 1;
        
            var reader = new FileReader();
        
            // If we use onloadend, we need to check the readyState.
            reader.onloadend = function(evt) {
              if (evt.target.readyState == FileReader.DONE) { 
                var contents = evt.target.result;
                continuation(contents);
              }
            };
            
            if (file.webkitSlice) {
              var blob = file.webkitSlice(start, stop + 1);
            } else if (file.mozSlice) {
              var blob = file.mozSlice(start, stop + 1);
            } else {
              alert("File blob interface not supported for this browser.  Use a different mode or switch browsers.  Recent Firefox or Chrome browsers work.");
            }  
            reader.readAsText(blob);        
      }
      
      function get_header(filename, file_string) {
            if (/.fits$/.test(filename)) {
                return fits_get_header(file_string);
            } else {
                alert("Browser can't handle headers for this file type.   Use 'Uploaded' instead.");
                return "";
            }
      }
      
      function fits_get_header(file_string) {
            var record_no = 0;
            var rec = fits_read_record(file_string, record_no);
            var header = "";
            while (rec.length) {
                var result = header_lines(get_cards(rec));
                header += result[0];
                if (result[1]) {
                    return header;
                }
                record_no += 1;
                rec = fits_read_record(file_string, record_no);
            }
            return header;
      }
      
      function fits_read_record(file_string, record_no) {  // read a FITS record
        var beg = 2880*record_no;
        var end = Math.min(file_string.length, 2880*(record_no + 1));
        // console.log(record_no + " " + beg + " " + end);
        return file_string.slice(beg, end);
      }
      
      function get_cards(record) {
        var i = 0;
        var cards = new Array();
        for ( ; 80*i < record.length; i++) {
            cards[i] = record.slice(80*i, 80*(i+1));
        }
        return cards;
      }
      
      function header_lines(cards) { // Return "header lines" assoc with cards
        var i;
        var header = "";
        for(i in cards) {
            var card = cards[i];
            header += card_line(card);
            if (fits_keyword(card) == "END") {
                return [ header, true ];
            }
        }
        return [ header, false ];
      }
      
      function card_line(card) {  // format a card into "<key> <value> <eol>"
            var key = fits_keyword(card);
            var value;   
            if (card.indexOf("/") > 0) { // handle comments
                value = $.trim(card.slice(10, card.indexOf("/")));
            } else {
                value = $.trim(card.slice(10, card.length));
            }
            if (value[0] == "'") {
                value = $.trim(value.slice(1, value.length-1));
            }
            var line = key + " " + value + "\n";
            if ($.trim(line)) {
                return line;
            } else {
                return "";
            }
      }
      
      function fits_keyword(card) {   // return the FITS keyword of a card.
        return $.trim(card.slice(0,8));
      }     
      
     function basename (path, suffix) {
        var b = path.replace(/^.*[\/\\]/g, '');     
        if (typeof(suffix) == 'string' && b.substr(b.length - suffix.length) == suffix) {
            b = b.substr(0, b.length - suffix.length);
        }
        return b;
     }     
      
      function set_contents(evt) {
        var event = window.event || evt;
        var file = event.target;
        readBlob(file.id, function (contents) {
            // replace the file element with a text area containing header lines
            var header_val = get_header(file.value, contents);
            if (!header_val) {
                file.value = "";
                set_radio("dataset_mode","dataset_uploaded");
                return;
            }
            var header_textarea = $("<textarea name='dataset_local' rows='5' cols='40'>")
                                 .text(header_val)
            var dataset_name = $("<input type='hidden' name='dataset_name'/>")
                                .val(basename(file.value));
            $("#dataset_local").after(header_textarea);
            header_textarea.after(dataset_name);
            $("#dataset_local").remove();
        }); 
        set_radio("dataset_mode", "dataset_local");
      }
      
      function set_radio(radio_name, radio_value) {
        $("input:radio[name=" + radio_name + "]").prop("checked", false);
        $("input:radio[value=" + radio_value + "]").prop("checked", true);
      }

      function submit_bestrefs() {
        // copy inputs to a secondary form to work around file input 
        // for dataset_local
        return true;
        var form = $("<form>");
        var elem;
        for (el in $("#raw_form input :not([type=file])")) {
            form.append(elem);
        }
        form.append($("#raw_form input[name=dataset_upload]"));
        form.submit();
        return false; // don't submit raw form
      }

</script>


  <form id="raw_form" action="/bestrefs/" method="post"" enctype="multipart/form-data"> {% csrf_token %}
    <h2>Get Best References</h2>
    
    <h3>Context:</h3>
    {% include "select_pmap.html" %}
    
    <h3>Dataset:</h3>
    <table>
      <tr>
        <td>
           <input type="radio" name="dataset_mode" value="dataset_uploaded" checked>Uploaded
        </td>
        <td align="right">
           <input type="file" class="multi" maxlength="1" name="dataset_uploaded"
                    onchange="set_radio('dataset_mode', 'dataset_uploaded');" />
        </td> 
      </tr>
      <tr>
        <td>
            <input type="radio" name="dataset_mode" value="dataset_archive" />Archived
        </td>
        <td align="left">
            <input type="text" width="32" name="dataset_archive" 
                    value="{{dataset_archive}}" 
                    onchange="set_radio('dataset_mode','dataset_archive');" />
        </td>
      </tr>
      <tr>
        <td>
            <input type="radio" name="dataset_mode" value="dataset_local">FITS Header
        </td>
        <td align="left">
            <input type='file' id='dataset_local' onchange='set_contents();' />
        </td>
      </tr>
    </table>
    
    <br/>
    <input type="submit" value="Submit" onsubmit="submit_bestrefs();" />
    
  </form>
{% endblock column1 %}

{% block help %}

    <p><b>Dataset Best References</b> lets you determine the best reference files 
    for an archived or uploaded dataset, relative to the chosen CRDS context.
    
    <p><p><b>Context</b> this section defines the version of the pipeline 
    context that should be used to determine the best reference files. The 
    context file chosen defines the parameter choices which will be available 
    as well as complete file selection criteria.

    <p><p><b>Dataset</b> Dataset specifies the name of an archived or uploaded 
    dataset for which the user needs to know the best references files that are 
    defined by the chosen context.  FITS Header Only uses your browser to 
    minimize file information uploaded to the server for FITS files.

{% endblock help %}