{% extends "base.html" %}

{% block column1 %}
    <h2>Certify File</h2>
    <form method="post" action="/certify/" enctype="multipart/form-data"> 
      {% csrf_token %}
      <table width="100%">
        <tr>
          <td width="5%">
            <input type="radio" name="filemode" value="file_uploaded" checked />
          </td>
          <td width="25%" class="label">Uploaded File:</td>
          <td width="25%">
            <input type='file' name='file_uploaded' size="32">
          </td>
        </tr>
        <tr>
          <td width="5%">
                <input type="radio" name="filemode" 
                        value="file_known" />
          </td>
          <td width="25%" class="label">Known File:</td>
          <td width="25%">
            <input type='text' name='file_known' size="32" 
                value="{{file_known}}">
          </td>
        </tr>
        <tr></tr>
      </table>
      <p></p>
      <input type="submit" value="Certify File">
    </form>
{% endblock column1 %}

{% block help %}

<p><b>Certify</b> Certify runs the same checks required for submission and
presents any errors as well as provenance information for review.

<p><p><b>Uploaded File</b> lets you temporarily upload a prototype reference or 
mapping to the CRDS server for certification.

<p><p><b>Known File</b> lets you re-certify a mapping or reference
which has already been submitted to CRDS.

<p><p><b>Check References</b> essentially turns on "deep" certification in which
the reference files implied by a mapping can themselves be certified.

<p><p>NOTE: If you have installed CRDS,  you can certify files locally like 
this:
<pre>% python -m crds.certify ./hst_acs_biasfile_0001.rmap</pre> 
<pre>% python -m crds.certify --dump-provenance ./myfile.fits</pre>
{% endblock help %}
