#! /usr/bin/env python
#-*-python-*-
from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
from future import standard_library
standard_library.install_aliases()
from builtins import *
import os, os.path, sys

import django
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "crds.server.settings")
django.setup()

from crds.core import rmap, log, pysh
from crds.server import config
from crds.server.interactive import models
from crds.server.interactive import submit

def find_undelivered_catalogs():
    """Look through the file database for files in state 'delivered'.

    Return sorted(set([catalog_basenames, ...]))
    """
    log.info("Searching for 'delivered' files.")
    catalogs = set()
    for name, blob in list(models.get_fileblob_map().items()):
        if blob.state == "delivered":
            blob.thaw()
            catalogs.add(os.path.basename(blob.catalog_link))
    catalogs = sorted(list(catalogs))
    log.info("Found undelivered catalogs:", catalogs)
    return catalogs

def reduce_to_existing(catalogs):
    """Return the list of catalogs that actually exist as files in the
    catalogs directory.   This supports redelivering a range of catalogs
    after the file delivery directory has been wiped prior to truly 
    delivering the files by filtering out duds.
    """
    existing = []
    for catalog in catalogs:
        if not os.path.exists(os.path.join(config.CRDS_CATALOG_DIR, catalog)):
            log.info("Skipping missing catalog", catalog)
            continue
        existing.append(catalog)
    return existing

def wipe_delivered_files(files):
    """Remove any existing links for `files` from the delivery directory
    """
    filepaths = [os.path.join(config.CRDS_DELIVERY_DIR, file) for file in files]
    for path in filepaths:
        with log.verbose_on_exception("Failed removing", repr(path)):
            pysh.sh("rm -f $path", raise_on_error=True)
            log.info("Removed existing file", repr(path))

def redeliver_catalogs(catalogs):
    """Make the delivery link for all the files in catalogs.  This does not
    update the database or create and AuditBlob since it's intended for restoring
    file system consistency re-making the hard links used in deliveries.
    """
    models.add_meta_event(f"Redelivered catalogs: {catalogs}")
    for cat in catalogs:
        log.info("Redelivering", repr(cat))
        catalog_path = os.path.join(config.CRDS_CATALOG_DIR, cat)
        delivered_catalog = os.path.join(config.CRDS_DELIVERY_DIR, cat)
        files = open(catalog_path).read().splitlines()
        filepaths = [rmap.locate_file(file, models.OBSERVATORY) for file in files]
        wipe_delivered_files(files + [delivered_catalog])
        with log.error_on_exception("Failed redelivering", repr(cat)):
            delivery =  submit.Delivery("fake user", models.OBSERVATORY, filepaths, "fake description", "fake action")
            delivery.deliver_make_links(catalog_path, filepaths)
        deliveries = os.path.join(config.CRDS_DELIVERY_DIR, "*")
        pysh.sh("chmod 444 ${deliveries}")

def basecatalog(filename):
    """Given a catalog filename,  return the filename after removing any delivery processing suffix
    to restore it to the root catalog name.  Ignore paths.
    """
    return filename.lower().replace("_proc","").replace("_submit","").replace("_error","")

def relink_filelist(files):
    """Relink an arbitrary list of files which don't necessarily have a single catalog listing them
    and may in fact include multiple catalogs,  e.g. all existing delivered files from a backup list.
    """
    wipe_delivered_files(files)
    for filename in files:
        if filename.endswith("*"):
            filename = filename[:-1]
        if rmap.is_mapping(filename):
            source_path = rmap.locate_mapping(filename)
        elif basecatalog(filename).endswith(".cat"):
            source_path = os.path.join(config.CRDS_CATALOG_DIR, basecatalog(filename))
        else:
            source_path = rmap.locate_file(filename, models.OBSERVATORY)
        dest_path = os.path.join(config.CRDS_DELIVERY_DIR, filename)
        log.info("Relinking", repr(dest_path), "-->", repr(source_path))
        with log.error_on_exception("Failed relinking",repr(dest_path), "-->", repr(source_path)):
            pysh.sh("rm -f $dest_path")
            os.link(source_path, dest_path)

def main():
    pysh.usage("[--find-undelivered-catalogs] | --catalogs [<catalogs_to_redeliver...>] | --filelist <deliver_dir_filelist>", 1)

    if "--find-undelivered-catalogs" in sys.argv:
        sys.argv.remove("--find-undelivered-catalogs")
        catalogs = find_undelivered_catalogs()
        redeliver_catalogs(catalogs)
    elif "--catalogs" in sys.argv:
        sys.argv.remove("--catalogs")
        catalogs = sys.argv[1:]
        redeliver_catalogs(reduce_to_existing(catalogs))
    elif "--files" in sys.argv:
        sys.argv.remove("--files")
        relink_filelist(sys.argv[1:])
    else:
        raise RuntimeError("Invalid command line options.")

if __name__ == "__main__":
    main()

