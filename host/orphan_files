#! /usr/bin/env python
"""This script looks for inconsitencies between the server database, 
server file cache at CRDS_PATH, and the server catalogs and deliveries directories.

When used to maintain a single server,  the switch --purge-delivery-errors can
clean up files in the catalog and delivery directories.

When used in the context of mirroring,  --purge-delivery-errors is moot because
the catalogs and deliveries directories are recreated.
"""

import sys
import os.path
import glob
import re

import django
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "crds_server.settings")
django.setup()

from crds.core import rmap, log
from crds_server import config
from crds_server.interactive import models as imodels

def file_conjugate(path):
    """Nominally the opposing half of a GEIS file,  data for header or header for data.
    Easily expandable to any binary filetype, less so to multi-part non-binary types.
    """
    if re.match(".*\.r\dd", path):
        conjugate = path[:-1] + "h"
    elif re.match(".*\.r\dh", path):
        conjugate = path[:-1] + "d"
    else:
        conjugate = None
    return conjugate

def check_exists(path):
    if not os.path.exists(path):
        return False
    conjugate = file_conjugate(path)
    if conjugate:
        if not os.path.exists(cojugate):
            log.error("Missing file conjugate", repr(conjugate), "corresponding to", repr(path))
            return False
        else:
            log.verbose("Checking file congjugate", repr(conjugate), "corrsponding to", repr(path), "exists.")
    return True

def all_rules_files(mapping_glob="*.*map"):
    """Return (mapping_names, reference_names) for all mappings which match `mapping_glob`"""
    all, mappings, references = [], [], []
    for fname in rmap.list_mappings(mapping_glob, observatory=imodels.OBSERVATORY):
        with log.error_on_exception("FAILED loading mapping", repr(fname)):
            pmap = rmap.get_cached_mapping(fname)
            references += pmap.reference_names()
            mappings += pmap.mapping_names()
            all = references + mappings
    return set(all)

def check_files():
    db_files = imodels.get_fileblob_map()
    cached_files = rmap.list_mappings("*", imodels.OBSERVATORY) + rmap.list_references("*", imodels.OBSERVATORY)
    mapping_files = all_rules_files()
    missing = dict()
    missing.update(check_consistency("database", "cache", db_files, cached_files))
    missing.update(check_consistency("database", "mappings", db_files, mapping_files))
    missing.update(check_consistency("cache", "mappings", cached_files, mapping_files))
    if union(list(missing.values())):
        log.warning("Inconsistent files:\n", log.PP(missing))
    intersections = dict()
    for key1, files1 in list(missing.items()):
        for key2, files2 in list(missing.items()):
            if key1 != key2 and (key2, key1) not in intersections:
                intersections[(key1, key2)] = set(files1).intersection(set(files2))
    if union(list(intersections.values())):
        log.warning("Inconsitency intersections:\n", log.PP(intersections))

def union(sets):
    u = set()
    for s in sets:
        u = u.union(s)
    return u

def check_consistency(name1, name2, files1, files2):
    missing = dict()
    missing[name1 + ":not-in:" + name2] = _check_consistency(name1, name2, files1, files2)
    missing[name2 + ":not-in:" + name1] = _check_consistency(name2, name1, files2, files1)
    return missing

def _check_consistency(name1, name2, files1, files2):
    missing = set()
    for file in files1:
        log.verbose("Checking", name1, "file", repr(file), "against", name2)
        if file not in files2 and file_conjugate(file) not in files2:
            log.error("Orphaned", name1, "file", repr(file), "is not in", name2)
            missing.add(file)
        conjugate = file_conjugate(file)
        if conjugate and name2 != "mappings":
            log.verbose("Checking", name1, "conjugate", repr(conjugate), "corresponding to", repr(file), "against", name2)
            if conjugate not in files2:
                log.error("Missing", name1, "conjugate", repr(conjugate), "is not in", name2)
                missing.add(file)
    return missing

def delivered_path(name):
    return os.path.join(config.CRDS_DELIVERY_DIR, name)

def check_catalog_files():
    """Check consistency between CRDS catalogs in delivery area and delivered files."""
    db_files = imodels.get_fileblob_map()
    pending_catalogs = glob.glob(config.CRDS_DELIVERY_DIR + "/*.*cat")
    all_catalogued_files = []
    for catalog in pending_catalogs:
        log.verbose("Scanning catalog", repr(catalog))
        manifested_files = open(catalog).read().splitlines()
        for manifested_file in manifested_files:
            log.verbose("Scanning manifested file", repr(manifested_file))
            manifest_path = delivered_path(manifested_file)
            if not check_exists(manifest_path):
                purge_delivered_file(catalog, "Manifested file", repr(manifest_path), "from catalog", 
                                    repr(catalog), "does not exist.")
                
            if manifested_file not in db_files:
                purge_delivered_file(manifest_path, "Manifested file", repr(manifest_path), "from catalog", 
                                    repr(catalog), "is not known to CRDS.")
        all_catalogued_files += manifested_files
    delivered_files = glob.glob(config.CRDS_DELIVERY_DIR + "/*")
    for file in delivered_files:
        if ".cat" not in file and os.path.basename(file) not in all_catalogued_files:
            # log.verbose("All catalogued files:", all_catalogued_files)
            purge_delivered_file(file, "Delivered file", repr(file), "has no corresponding catalog in delivery area.  Possibly catalog deleted without removing file link.")
    for file in [ f for f in list(db_files.values()) if f.state == "delivered" ]:
        if file.name not in all_catalogued_files:
            log.error("File", repr(file.name), "with state 'delivered' does not appear in an undelivered catalog.")
        if not os.path.exists(delivered_path(file.name)):
            log.error("File", repr(file.name), "with state 'delivered' is not linked to the delivery directory.")
    for file in [ f for f in list(db_files.values()) if f.state == "uploaded" ]:
        log.warning("File", repr(file.name), "delivered on", file.delivery_date, "has state 'uploaded'.")

def purge_delivered_file(filepath, *args, **keys):
    """Remove `filepath` and issue an error message defined by `args` and `keys`."""
    log.error(*args, **keys)
    try:
        if "--purge-delivery-errors" in sys.argv:
            os.chmod(filepath, int('0666', 8))
            os.remove(filepath)
            log.info("Removed", repr(filepath))
    except Exception:
        pass

def main():
    if "--verbose" in sys.argv:
        log.set_verbose()
    import django
    django.setup()
    check_files()
    check_catalog_files()
    log.standard_status()

if __name__ == "__main__":
    main()

