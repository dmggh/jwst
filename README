1. General server setup flow is:

# On server VMs, initialize the environment from ~crds/.setenv,  a *global* rc file
# shared by all VMs which should only be changed with caution.

% source ~/.setenv  
% server  # alias to cd to CRDS_server source code

Following the CRDS server simplify-install-config effort, the .setenv/.cshrc
file should be used to define all server configuration parameters, currently
based on the hostname to define the string identity.  Environment variables in
turn are passed into install scripts and Python's os.environ for use defining
global constants which mirror the environment.

The CRDS server "Python stack" consists of relatively slowly changing CRDS
dependencies like the astropy, asdf, Django, memcached, fitsverify, and the
JWST CAL code.   The key property of these packages is that they are not 
constantly re-installed as CRDS application code is modified and run.

Setup the server python stack by going to CRDS_sever/servers/stack_build
and running build_conda3::

$ server
$ cd stack_build
$ ./build_conda3 |& tee build_conda3.err

build_conda3 installs a mixture of private CRDS downloads that are CM'ed at
/eng/ssb/crds/installer4 and conda packages.  Copies of installer 4 are made
on each VM during installation.

Classically the  4 CRDS server "use cases"::

dev    Apache / VM / Isilon / MySQL / Proxy / mod_wsgi development server
test   Apache / VM / Isilon / MySQL / Proxy / mod_wsgi pipeline test server
ops    Apache / VM / Isilon / MySQL / Proxy / mod_wsgi pipeline production server

JWST uniquely has an additional I&T usecases with similar components:

bit   build 7.1 i&t server   (string B)
cit   build 7.1.3 i&t server   (string C)

Install the CRDS client and server code, as well as Apache config files:

./install

2. Procedure for starting the sever:

% crds_start

3. Procedure for installing and restarting the server:

% crds_rerun

4. Procedure for running a command line / ipython environment for debug

% crds_manage shell

5. Procedure for running server self-tests:

% crds_runtests

or 

6. Procedure for running Django management commands

% ./crds_manage <additional parameters to django-admin.py>

e.g.


7. Database commands

% ./crds_manage dbshell  # to open a SQL prompt to the CRDS server database

% ./crds_manage dbbackup  # to create a django-dbbackup server database backup
% ./crds_manage dbrestore <backup file>   # to revert to an older version of the database

Typically dbbackup and restore are done by wrapper scripts in the tools directory:

backup_server
restore_server

which implicitly use save sets for the current server.  the tools scripts also include
aspects of the server from the file system in addition to the database.   The 1T+ file
caches are not backed up,  if needed they are mirrored from another system or sync'ed
from the archive (once available).

backup_server and restore_server maintain backup files in two locations:

* there is a private dated location (currently under $CRDS/...) containing multiple backups.

* there is a shared undated location (currently under /eng/ssb/crds/...) containing the last
backup for each server which is used to facilitate mirroring.


8. Mirroring

e.g. copy the test server (hst-crds-test, tlhstcrds) down to the dev server (hst-crds-dev, dlhstcrds).

This replicates the database and syncs the cache and server support directories.   This is only recommended
in a *downward* ops -> test -> dev direction.  It stops and restarts the server as required.

First,  on the source server:

# login tlhstcrds
% server
% backup_server

That puts required backup files in the shared /eng/ssb/crds/...

Second,  on the destination server:

# login dlhstcrds
% server
% mirror_server hst test https://hst-crds-test.stsci.edu |& tee mirror_server.hst.test.err

where the parameters to mirror_server specify the *source* server and the destination is
implicitly the server of the current login.

If the state of the mirrored server has changed since the nightly backup,  manually running the
backup_server script is required prior to mirroring in order to capture and mirror the latest
state.

If no state change has occurred since the nightly backup,  the source server backup step can be skipped.

