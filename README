1. General server setup flow is:

# On server VMs, initialize the environment from ~crds/.setenv,  a *global* rc file
# shared by all VMs which should only be changed with caution.

% source ~/.setenv  
% server  # alias to cd to CRDS_server source code

Setup the server python stack by going to CRDS_sever/servers/stack_build
and running build_conda3::

$ server
$ cd servers/stack_build
$ ./build_conda3 |& tee build_conda3.err

build_conda3 installs a mixture of private CRDS downloads that are CM'ed at
/eng/ssb/crds/installer4 and conda packages.  Copies of installer 4 are made
on each VM during installation.

Classically tere 4 CRDS server "use cases"::

django    Django/SQLite django server
dev  Apache/VM/Isilon/MySQL/Proxy/mod_wsgi development server
test   Apache/VM/Isilon/MySQL/Proxy/mod_wsgi pipeline test server
ops   Apache/VM/Isilon/MySQL/Proxy/mod_wsgi pipeline production server

JWST uniquely has an additional I&T usecases:

dit   build 7 i&t server     (string D)
bit   build 7.1 i&t server   (string B)
cit   build 7.1.3 i&t server   (string C)

During a brief test period in winter/spring 2018 the JWST TEST server was
utilized as part of an ad hoc A-string given to DPAS for practice/testing.
During that period it was interfaced to the A-string pipeline and TEST version
of the AUI.

# Install the code as indicated by the appropriate config file from
# sources/configs/config.<observatory>.<server_kind>
./install [hst|jwst]  [django|dev|test|ops|dit|bit|cit|ait]

This creates CRDS_server/env.csh as well as ./run and ./stop scripts.

2. Procedure for starting the sever:

% ./run

3. Procedure for installing and restarting the server:

% ./rerun

4. Procedure for running a command line / ipython environment for debug

% ./manage shell

5. Procedure for running server self-tests:

% ./rerun
% ./runtests

or 

6. Procedure for running Django management commands

% ./manage <additional parameters to django-admin.py>

e.g.


7. Database commands

% ./manage dbshell  # to open a SQL prompt to the CRDS server database

% ./manage dbbackup  # to create a django-dbbackup server database backup
% ./manage dbrestore <backup file>   # to revert to an older version of the database

Typically dbbackup and restore are done by wrapper scripts in the tools directory:

backup_server
restore_server

which implicitly use save sets for the current server.  the tools scripts also include
aspects of the server from the file system in addition to the database.   The 1T+ file
caches are not backed up,  if needed they are mirrored from another system or sync'ed
from the archive (once available).

backup_server and restore_server maintain backup files in two locations:

* there is a private dated location (currently under $CRDS/...) containing multiple backups.

* there is a shared undated location (currently under /eng/ssb/crds/...) containing the last
backup for each server which is used to facilitate mirroring.


8. Mirroring

e.g. copy the test server (hst-crds-test, tlhstcrds) down to the dev server (hst-crds-dev, dlhstcrds).

This replicates the database and syncs the cache and server support directories.   This is only recommended
in a *downward* ops -> test -> dev direction.  It stops and restarts the server as required.

First,  on the source server:

# login tlhstcrds
% server
% backup_server

That puts required backup files in the shared /eng/ssb/crds/...

Second,  on the destination server:

# login dlhstcrds
% server
% mirror_server hst test https://hst-crds-test.stsci.edu |& tee mirror_server.hst.test.err

where the parameters to mirror_server specify the *source* server and the destination is
implicitly the server of the current login.

If the state of the mirrored server has changed since the nightly backup,  manually running the
backup_server script is required prior to mirroring in order to capture and mirror the latest
state.

If no state change has occurred since the nightly backup,  the source server backup step can be skipped.

