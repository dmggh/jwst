1. General server setup flow is:

# On server VMs, initialize the environment from ~crds/.setenv,  a *global* rc file
# shared by all VMs which should only be changed with caution.

% source ~/.setenv  
% server  # alias to cd to CRDS_server source code

Setup the server python stack by building the crds packages list from the installer3 system.
Look at host/build_stack for the process of building the stack.
The master installer3 mercurial repo is at /eng/ssb/crds/installer3.  Copies are on each VM.

There 4 CRDS server "use cases".

django    Django/SQLite django server
dev  Apache/VM/Isilon/MySQL/Proxy/mod_wsgi development server
test   Apache/VM/Isilon/MySQL/Proxy/mod_wsgi pipeline test server
ops   Apache/VM/Isilon/MySQL/Proxy/mod_wsgi pipeline production server

JWST uniquely has an additional two usecases:

b5it  build 5 frozen i&t server     (string B)
b6it  build 6 frozen i&t server     (string C)
b7it  build 7 frozen i&t server     (string A)

# Install the code as indicated by the appropriate config file from
# sources/configs/config.<observatory>.<server_kind>
./install [hst|jwst]  [django|dev|test|ops|b5it|b6it|b7it]

# Possibly re-run install if the first run failed due to missing packages
./install [hst|jwst]  [django|dev|test|ops|b5it|b6it|b7it]

# Initilize the CRDS catalog with existing reference files, deliver initial
# set of mappings.   Generally this is no longer done,  except maybe for private Django dev-server installations.
# Enter system passwords.

./init [hst|jwst] [django|dev|test|ops|b5it|b6it|b7it]
<enter password for test user>

XXXX NOTE: the process of running ./init is now obsolete, the servers are mature and server
state is maintained in the database and file system.  mirroring servers from OPS to a 
lower level use case is now the preferred method of setting up new servers.

2. Procedure for starting the sever:

% ./run

3. Procedure for update not affecting the database:

% ./rerun [hst|jwst] [django|dev|test|ops|b5it|b6it|b7it]

4. Procedure for running a command line / ipython environment for debug

% ./shell

5. Procedure for running HST server self-tests.

% ./rerun
% ./runtest (2nd terminal)

or 

6. Procedure for running Django management commands

% ./manage <additional parameters to django-admin.py>

e.g.


7. Database commands

% ./manage dbshell  # to open a SQL prompt to the CRDS server database

% ./manage dbbackup  # to create a django-dbbackup server database backup
% ./manage dbrestore <backup file>   # to revert to an older version of the database

Typically dbbackup and restore are done by wrapper scripts in the tools directory:

backup_server
restore_server

which implicitly use save sets for the current server.  the tools scripts also include
aspects of the server from the file system in addition to the database.   The 1T+ file
caches are not backed up,  if needed they are mirrored from another system or sync'ed
from the archive (once available).

backup_server and restore_server maintain backup files in two locations:

* there is a private dated location (currently under $CRDS/...) containing multiple backups.

* there is a shared undated location (currently under /eng/ssb/crds/...) containing the last
backup for each server which is used to facilitate mirroring.


8. Mirroring

e.g. copy the test server (hst-crds-test, tlhstcrdsv1) down to the dev server (hst-crds-dev, dlhstcrdsv1).

This replicates the database and syncs the cache and server support directories.   This is only recommended
in a *downward* ops -> test -> dev direction.  It stops and restarts the server as required.

First,  on the source server:

# login tlhstcrdsv1
% server
% backup_server

That puts required backup files in the shared /eng/ssb/crds/...

Second,  on the destination server:

# login dlhstcrdsv1
% server
% mirror_server hst test https://hst-crds-test.stsci.edu |& tee mirror_server.hst.test.err

where the parameters to mirror_server specify the *source* server and the destination is
implicitly the server of the current login.

If the state of the mirrored server has changed since the nightly backup,  manually running the
backup_server script is required prior to mirroring in order to capture and mirror the latest
state.

If no state change has occurred since the nightly backup,  the source server backup step can be skipped.

