#! /usr/bin/env python
#-*-python-*-

"""This is a generic installation script I cobbled together for setting up my
own Python environments.
"""

import sys, os, os.path
import shutil
import hashlib
import pprint
import datetime
import glob as _glob
import argparse

try:   
    import StringIO
except:  # python3
    import io as StringIO

try:
    SEP = os.path.sep
except:
    SEP = "/"

# ==================================================================
# ==================================================================

def exists(name):
    x = os.path.exists(name)
    verbose("Checking for", repr(name), "in", repr(os.getcwd()), "exists:", x)
    return x

def tell(*args, **keys):
    file   = keys.get("file", sys.stderr)
    eol    = keys.get("eol", "\n")
    sep    = keys.get("sep", " ")
    marker = keys.get("marker", "--> ")
    
    file.write(marker)
    for a in args:
        file.write(str(a) + sep)
    file.write(eol)
    file.flush()

def error(*args, **keys):
    keys["marker"] = "**> ERROR "
    tell(*args, **keys)

def warn(*args, **keys):
    keys["marker"] = "==> Warning: "
    tell(*args, **keys)
    
def verbose(*args, **keys):
    """
    Function like 'print' which prints space separated parameters followed 
    by newline, if-and-only-if verbose printing is turned on.
    """
    if not ARGS.verbose:
        return
    tell(*args, **keys)


def fixpath(p):
   """Convert windows \\ paths back to / paths for Msys"""
   parts = [x for x in p.split(SEP) if x]
   newp = "/".join(parts)
   if p.startswith(SEP):
       newp = SEP + newp
   # verbose("fixpath:",p,"->",newp)
   return newp

def evalfile(filename):
    return eval(open(filename).read())

# ==================================================================
# ==================================================================

PREFIX = os.environ.get("META_PREFIX", fixpath(os.getcwd()))

try:
    PACKAGE_PATH = fixpath(os.environ["PACKAGE_PATH"])
except KeyError:
    PACKAGE_PATH = "../sources"

# ==================================================================
# ==================================================================

def prune(*dirs):
    """Delete a directory tree."""
    tell(*(("Pruning",) + dirs))
    errors = []
    for d in dirs:
        if os.path.exists(d):
            verbose("Pruning:", repr(d))
            try:
                shutil.rmtree(d)
            except:
                errors.append(d)
        if errors:
            raise OSError("Failed to remove: " + repr(errors))

def glob(pat):
    """A file pattern globber which fixes paths for Windows."""
    files = _glob.glob(pat)
    return [fixpath(f) for f in files]

# ==================================================================
# ==================================================================

def pkg_pattern(fname):
    """
    >>> pkg_pattern("../sources/foo-1.0.tar.gz")
    'foo'
    >>> pkg_pattern("../sources/foo-bar-1.0.tar.gz")
    'foo-bar'
    >>> pkg_pattern("../sources/foo.meta")
    'foo'
    >>> pkg_pattern("../sources/foo-bar.meta")
    'foo'
    """
    pkg_with_version = ".".join(os.path.basename(fname).split(".")[:-1])
    versionless = "-".join(pkg_with_version.split("-")[:-1])
    # pkg_with_version may not have a version...
    return versionless or pkg_with_version
    
class Package(object):
    def __init__(self, package_source, build_dir=None, **keys):
        self.filename = package_source
        self.filepat = pkg_pattern(package_source)
        self.build_dir = build_dir or self.natural_dir()
        self.dirs = []
        for k in keys.keys():
            setattr(self, k, keys[k])

    def discover_archive(self, filepat, pkg_path="."):
        files = sorted(glob(pkg_path + "/" + filepat + "*"))
        exact = [f for f in files if f[len(pkg_path+"/"+filepat)] == "-"]
        if exact:
            files = exact
        if len(files) > 1:
            warn("more than one match for:", \
                  repr(filepat), files)
        elif not len(files):
            raise RuntimeError("No archive found for " + repr(filepat))
        return files[-1]
    
    def split_name(self):
        name, ext = os.path.splitext(self.filename)
        parts = name.split("-")
        if len(parts) > 1:
            base = "-".join(parts[:-1])
            version = parts[-1]
        else:
            base = name
            version = "unknown"
        return os.path.basename(base), version

    def __str__(self):
        return self.build_dir

    def system(self, *args):
        """Executes native os commands with usages:
        1. system(field1, field2, field3, ...)   # args are joined with spaces
        2. system(lines)  # multi-line strings are executed as seperate commands
        """
        s = " ".join(args)
        for l in StringIO.StringIO(s).readlines():
            l = l.strip()
            if sys.platform.startswith("win") and l.startswith("./"):
                l = "sh " + l
	    	# l = "sh -x " + l
            tell("Executing:", repr(l), file=sys.stderr)
            retval = os.system(l)
            if retval != 0:
                raise SystemError("Command " + repr(l) + "failed with status = " + str(retval))

    def nested_system(self, *args, **keys):
        dir = keys.get("dir", None)
        """Executes the system command in the package directory."""
        self.pushdir(dir)
        try:
            self.system(*args)
        finally:
            self.popdir()

    def build(self):
        self.unpack()
        self.configure()
        self.make()

    FORMATS = {
        ".tgz"     : "tar_gz",
        ".tar.gz"  : "tar_gz",
        ".tar.bz2" : "tar_bz2",
        ".zip"     : "zip",
        ".meta"    : "tar",
        ".jar"     : "jar",
        ".pygz"    : "tar_gz",
        }

    def root_ext(self, name):
        """Breaks an archive name into a rootname and extension.
        """
        for ext, packer in self.FORMATS.items():
            if name.endswith(ext):
                # verbose("root_ext:", name[:-len(ext)], ext, packer)
                return name[:-len(ext)], ext, packer
        else:
            return None, None, None

    def natural_dir(self, name=None):
        """Returns the name of the directory into which an archive will
        unpack.
        """
        name = os.path.basename(name or self.filename)
        dir = self.root_ext(name)[0]
        if dir:
	    # verbose("natural_dir:", dir)
            return dir
        else:
            raise RuntimeError("No dir match for: " + repr(name))

    def unpack(self, name=None):
        target = name or self.filename
        root, ext, packer = self.root_ext(target)
        if root:
            return getattr(self, "un" + packer)(target)
        else:
            raise ValueError("Don't know how to unpack " + repr(target))

    def distclean(self):
        pass

    def pack(self):
        self.distclean()
        root, ext, packer = self.root_ext(os.path.basename(self.filename))
        if root:
            result = getattr(self, packer)(self.filename, self.natural_dir())
        else:
            raise ValueError("Problem packaging " + repr(self.filename))
        self.clean()
        return result
                
    def untar(self, archive):
        self.system("tar xf " + archive)

    def tar(self, archive, directory):
        self.system("tar cf", archive, directory)

    def unjar(self, archive):
        self.system("jar xf " + archive)

    def jar(self, archive, directory):
        self.system("jar cf ", archive, director)

    def untar_gz(self, archive):
        self.system("gunzip -c", archive, "| tar xf - ")

    def tar_gz(self, archive, directory):
        self.system("tar zcf", archive, directory)

    def untar_bz2(self, archive):
        self.system("tar jxf " + archive)

    def tar_bz2(self, archive, directory):
        self.system("tar jcf", archive, directory)

    def unzip(self, archive):
        self.system("unzip -d" + archive)

    def zip(self, archive, directory):
        self.system("zip -r", archive, directory)

    def pushdir(self, where=None):
        self.dirs.append(os.getcwd())
        self.cd(where or self.build_dir)

    def popdir(self):
        self.cd(self.dirs.pop(-1))

    def cd(self, d):
        tell("Changing dir to:", repr(d), file=sys.stderr)
        os.chdir(d)

    def configure(self):
        self.nested_system("./configure --prefix=" + repr(PREFIX))
        
    def make(self):
        self.nested_system("make", "-j10")

    def install(self):
        if not exists(self.build_dir):
            self.build()
        self.nested_system("make install")
        self.track_install()

    def clean(self, path=None):
        prune(self.build_dir)

    @property    
    def unpack_dir(self):    
        return self.build_dir.split("/")[0]
        
    def __repr__(self):
        return self.__class__.__name__ + "(" + repr(self.unpack_dir) + ")"

    @property
    def vcs_cmd(self):
        self.pushdir()
        try:
            for cmd in ["svn","hg","cvs"]:
                if os.path.exists("." + cmd):
                    return cmd
            else:
                raise RuntimeError("Can't determine VCS.")
        finally:
            self.popdir()

    # Version Control Commands
    
    checkout_cmd = {
        "svn":"co",
        "hg":"co",
        "cvs":"co",
        }

    def checkout(self, *args):
        self.system(self.vcs_cmd, self.checkout_cmd[self.vcs_cmd], self.url)

    update_cmd = {
        "svn":"update",
        "hg":"update",
        "cvs":"update",
        }

    def update(self, *args):
        self.unpack()
        self.nested_system(self.vcs_cmd, self.update_cmd[self.vcs_cmd], *args)
        self.pack()

    commit_cmd = {
        "svn":"commit",
        "hg":"commit",
        "cvs":"commit",
        }

    def commit(self, *args):
        self.nested_system(self.vcs_cmd, self.commit_cmd[self.vcs_cmd], self.url)

    log_cmd = {
        "svn":"log",
        "hg":"log",
        "cvs":"log",
        }

    def log(self):
        self.nested_system(self.vcs_cmd, self.log_cmd[self.vcs_cmd], self.url)

    merge_cmd = {
        "svn":"merge",
        "hg":"merge",
        "cvs":"merge",
        }

    def merge(self):
        self.nested_system(self.vcs_cmd, self.merge_cmd[self.vcs_cmd], self.url)

    move_cmd = {
        "svn":"move",
        "hg":"move",
        "cvs":"move",
        }

    def move(self):
        self.nested_system(self.vcs_cmd, self.move_cmd[self.vcs_cmd], self.url)


    copy_cmd = {
        "svn":"copy",
        "hg":"copy",
        "cvs":"copy",
        }

    def copy(self):
        self.nested_system(self.vcs_cmd, self.copy_cmd[self.vcs_cmd], self.url)

    def digest(self):
        sha1 = hashlib.sha1()
        f = open(self.filename, 'rb')
        try:
            sha1.update(f.read())
        finally:
            f.close()
        return sha1.hexdigest()

    def track_install(self):
        try:
            installs = evalfile("./packages.dat")
        except:
            warn("Couldn't load ./packages.dat.  Creating empty state.")
            installs = {}
        base, version = self.split_name()
        installs[base] = dict(
            date=str(datetime.datetime.now())[:-4], 
            version=version, 
            sha1=self.digest())
        open("./packages.dat","w+").write(pprint.pformat(installs))

# ==================================================================
# ==================================================================

class PythonPackage(Package):
    def __init__(self, *args, **keys):
        Package.__init__(self, *args, **keys)
        self.build_commands = ""
        self.install_commands = ""
        self.build_options = ""
        self.install_options = ""
        if ARGS.home:
            py_home_dir = ARGS.home
            if py_home_dir.startswith("."):
                py_home_dir = os.path.abspath(py_home_dir)
            self.install_options += " --home=" + repr(py_home_dir)

    def build(self, *args):
        if not exists(self.build_dir):
            self.unpack()
        commands = self.build_commands or \
                   " build %s" % (self.build_options,)
        self.nested_system(PYTHON, "setup.py", commands)

    def install(self, *args):
        if not exists(self.build_dir):
            self.build()
        commands = self.install_commands or \
                   " install --force %s" % (self.install_options,)
        self.nested_system(PYTHON, "setup.py", commands)
        self.track_install()

    def distclean(self):
        self.pushdir()
        try:
            prune("build")
        finally:
            self.popdir()

# ==================================================================
# ==================================================================

class MetaMixin(object):
    """A Meta-package has these properties:

    1. A top level .meta file is a .tar file.
    
    2. The package tree top level (self.build_dir) contains auxilliary
       files and scripts.
    
    3. A subtree contains the original package source.

    4. Auxilliary <verb>[.<platform>] files override the
       Package.<verb> method, so install.darwin would override
       Package.install for darwin. If both <verb> and
       <verb>.<platform> exist, only <verb>.platform is executed.
       If neither exist,  Package.<verb> is executed.
    """
    def __init__(self, *args, **keys):
        self.meta_dir = self.build_dir
        self.build_dir = self.meta_dir + "/" + self.meta_dir

    def __str__(self):
        return self.meta_dir
        
    def get_pristine_archive(self):
        if self.filepat.endswith("meta"):
            pat = self.filepat[:-4]
        else:
            pat = self.filepat
        return self.discover_archive(pat)
    
    def unpack(self):
        Package.unpack(self)
        self.pushdir(self.meta_dir)
        try:
            Package.unpack(self, self.get_pristine_archive())
        finally:
            self.popdir()

    def distclean(self):
        self.pushdir(self.meta_dir)    # meta source
        try:
            prune(self.meta_dir)      # source
        finally:
            self.popdir()

    def clean(self):
        prune(self.meta_dir)      # meta source

    def meta_command(self, cmd, *args):
        """Executes shell scripts in the meta directory for 'cmd', or
        reverts to superclass methods if the scripts don't exist.
        First tries for a platform specific version of the script,
        next for a generic version of the script, and finally a
        method.
        """
        if not exists(self.meta_dir):
            self.unpack()
        platform_specific_cmd = "./" + cmd + "." + sys.platform
        generic_cmd = "./" + cmd
        extra_args = (self.meta_dir, PREFIX, sys.platform, PYTHON) + args
        if exists(self.meta_dir + "/" + platform_specific_cmd):
            self.pushdir(self.meta_dir)
            try:
                self.system(platform_specific_cmd, *extra_args)
            finally:
                self.popdir()
        elif exists(self.meta_dir + "/" + generic_cmd):
            self.pushdir(self.meta_dir)
            try:
                self.system(generic_cmd, *extra_args)
            finally:
                self.popdir()
        else:
            verbose("Trying getattr(super)", cmd, "...", eol="")
            f = getattr(super(MetaMixin, self), cmd)
            verbose("succeeded.")
            self.pushdir(self.meta_dir)
            try:
                f(self, *args)
            finally:
                self.popdir()
        
    def build(self, *args):
        self.meta_command("build", *args)

    def install(self, *args):
        if not exists(self.build_dir):
            self.build(*args)
        self.meta_command("install", *args)
        self.track_install()

# ==================================================================
# ==================================================================

class MetaPackage(MetaMixin, Package):
    def __init__(self, *args, **keys):
        Package.__init__(self, *args, **keys)
        MetaMixin.__init__(self, *args, **keys)

# ===================================================================
# ===================================================================

class MetaPythonPackage(PythonPackage, MetaMixin):
    def __init__(self, *args, **keys):
        PythonPackage.__init__(self, *args, **keys)
        MetaMixin.__init__(self, *args, **keys)

    def meta_command(self, cmd, *args):
        MetaMixin.meta_command(self, cmd, PYTHON, *args)


# ===================================================================
# ===================================================================

def process(command, packages):
    if command == "list":
        for p in packages:
            tell("package:", p)
        return

    if command == "wipe":
        prune("bin", "lib", "man", "include", "share", "info")
        return

    failed = []
    for q in packages:
        try:
            f = getattr(q, command)
        except KeyError:
            error(command, "not implemented for", repr(q), file=sys.stderr)
        else:
            tell(command, repr(q), file=sys.stderr)
            try:
                f()
                tell(command, repr(q), "succeeded.", file=sys.stderr)
            except:
                error(command, repr(q), "failed:", sys.exc_info()[1],
                      file=sys.stderr)
                failed.append(q)
    if failed:
        error("Failed", repr(command), "for", repr(failed))
        sys.exit(-1)
    else:
        tell("Completed without errors.")

# ===================================================================
# ===================================================================

def endswith_any_of(s, endings):
    for ending in endings:
        if s.endswith(ending):
            return True
    else:
        return False

EXT_MAP = {
    (".pygz",)                   : PythonPackage,
    (".tar.gz","tgz",".tar.bz2") : Package,
    (".meta",)                   : MetaPackage,
    }

def autopkg(fname):
    """Factory which creates a subclass of Package based on filename `fname`."""
    for extensions, package_class in EXT_MAP.items():
        if endswith_any_of(fname, extensions):
            return package_class(fname)
    else:
        return None

def split_cmdline_args(args):
    """Split the args list into (package_basenames, command_line_source_files)
    
    >>> split_cmdline_args(['foo','bar','./source-1.0.tar.gz',])
    (('foo', 'bar', 'source'), ['./source-1.0.tar.gz'])
    
    """
    args2 = []
    arg_sources = []
    for arg in args:
        for extensions in EXT_MAP:
            if endswith_any_of(arg, extensions):
                arg_sources.append(arg)
                args2.append(pkg_pattern(arg))
                break
        else:
            args2.append(arg)
    return tuple(args2), arg_sources

def introspect(arg_sources=[]):
    """Define package table based on available package files and their
    extensions.   Use package sources supplied by the meta sources
    directory or on the command line.  The Package class or subclass is
    determined by the extension of the package file,  hence "introspect".

    Return { pkg_basename : Package }
    """
    source_files = _glob.glob(PACKAGE_PATH + "/*[az]")
    pkgs = {}
    for fname in source_files + arg_sources:
        pkg = autopkg(fname)
        if pkg:
            pat = pkg_pattern(pkg.filename)
            pkgs[pat] = pkg
    return pkgs

def load_package_list(words):
    """Convert a list of package names and package @file names into
    a list of Packages,  skipping blank lines and comments.
    """
    pkgs = []
    for w in words:
        if not w.strip() or w.startswith("#"):
            pass
        elif w.startswith("@"):
            nested = [l.strip() for l in open(w[1:]).readlines()]
            pkgs.extend(load_package_list(nested))
        else:
            try:
                pkgs.append(PACKAGES[w])
            except KeyError:
                error("Package",repr(w),"not found.")
    return pkgs

OR_VERBS = "pack|unpack|build|install|clean|wipe|update|test"
VERBS = OR_VERBS.split("|")

def is_dir(d):
    return d

def is_meta_verb(v):
    if v not in VERBS:
        raise argparse.ArgumentTypeError("Unknown META command " + repr(v))
    return v

def main():
    global PACKAGES, ARGS, PYTHON

    parser = argparse.ArgumentParser(
        description='Multi-purpose package installer')

    parser.add_argument(
        'verb', metavar=OR_VERBS, 
        type=is_meta_verb, help='operation for META to perform.')
    
    parser.add_argument(
        'names_and_sources', metavar='NAMES_AND_SOURCES', nargs='*',
        help='a list of package basenames or source files to operate on.')

    parser.add_argument(
        '--verbose', action="store_true", help="set log output to verbose mode.")
    
    parser.add_argument(
        "--python", dest="python", metavar="PYTHON_BINARY",
        type=is_dir, default=None, help='Python setup.py --home directory.')

    parser.add_argument(
        "--home", dest="home", metavar="HOME_DIR",
        default=None, help='Python executable this installation applies to.')

    ARGS = parser.parse_args()

    if ARGS.python:
        PYTHON = ARGS.python
    else:
        PYTHON = PREFIX + "/bin/python"

    verb_pkg_names, arg_sources = split_cmdline_args(ARGS.names_and_sources)

    PACKAGES = introspect(arg_sources)

    if ARGS.verb == "clean":
        pkgs = PACKAGES.values()
    elif ARGS.verb == "test":
            print test()
            sys.exit(0)
    else:
        pkgs = load_package_list(verb_pkg_names)

    process(ARGS.verb, pkgs)

# ===================================================================
# ===================================================================

def test():
    import doctest, meta
    return doctest.testmod(meta)

if __name__ == "__main__":
    main()

